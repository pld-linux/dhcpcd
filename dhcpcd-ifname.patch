Index: dhcpcd.c
==================================================================
--- dhcpcd.c
+++ dhcpcd.c
@@ -376,11 +376,11 @@
 
 	/* We want to disable kernel interface RA as early as possible. */
 	if (ifo->options & DHCPCD_IPV6RS) {
 		ra_global = if_checkipv6(ifp->ctx, NULL,
 		    ifp->ctx->options & DHCPCD_IPV6RA_OWN ? 1 : 0);
-		ra_iface = if_checkipv6(ifp->ctx, ifp->name,
+		ra_iface = if_checkipv6(ifp->ctx, ifp,
 		    ifp->options->options & DHCPCD_IPV6RA_OWN ? 1 : 0);
 		if (ra_global == -1 || ra_iface == -1)
 			ifo->options &= ~DHCPCD_IPV6RS;
 		else if (ra_iface == 0)
 			ifo->options |= DHCPCD_IPV6RA_OWN;

Index: if-bsd.c
==================================================================
--- if-bsd.c
+++ if-bsd.c
@@ -767,19 +767,20 @@
 
 int
 if_managelink(struct dhcpcd_ctx *ctx)
 {
 	/* route and ifwatchd like a msg buf size of 2048 */
-	char msg[2048], *p, *e, *cp, ifname[IF_NAMESIZE];
+	char msg[2048], *p, *e, *cp;
 	ssize_t bytes;
 	struct rt_msghdr *rtm;
 	struct if_announcemsghdr *ifan;
 	struct if_msghdr *ifm;
 	struct ifa_msghdr *ifam;
 	struct sockaddr *sa, *rti_info[RTAX_MAX];
 	int len;
 	struct sockaddr_dl sdl;
+	struct interface *ifp;
 #ifdef INET
 	struct rt rt;
 #endif
 #ifdef INET6
 	struct in6_addr ia6;
@@ -814,12 +815,11 @@
 			}
 			break;
 #endif
 		case RTM_IFINFO:
 			ifm = (struct if_msghdr *)(void *)p;
-			memset(ifname, 0, sizeof(ifname));
-			if (!(if_indextoname(ifm->ifm_index, ifname)))
+			if ((ifp = if_findindex(ctx, ifm->ifm_index)) == NULL)
 				break;
 			switch (ifm->ifm_data.ifi_link_state) {
 			case LINK_STATE_DOWN:
 				len = LINK_DOWN;
 				break;
@@ -836,11 +836,11 @@
 				 * As such, it is a race ...*/
 				len = LINK_UNKNOWN;
 				break;
 			}
 			dhcpcd_handlecarrier(ctx, len,
-			    (unsigned int)ifm->ifm_flags, ifname);
+			    (unsigned int)ifm->ifm_flags, ifp->name);
 			break;
 		case RTM_DELETE:
 			if (~rtm->rtm_addrs &
 			    (RTA_DST | RTA_GATEWAY | RTA_NETMASK))
 				break;
@@ -862,11 +862,11 @@
 		case RTM_CHGADDR:	/* FALLTHROUGH */
 #endif
 		case RTM_DELADDR:	/* FALLTHROUGH */
 		case RTM_NEWADDR:
 			ifam = (struct ifa_msghdr *)(void *)p;
-			if (!if_indextoname(ifam->ifam_index, ifname))
+			if ((ifp = if_findindex(ctx, ifam->ifam_index)) == NULL)
 				break;
 			cp = (char *)(void *)(ifam + 1);
 			get_addrs(ifam->ifam_addrs, cp, rti_info);
 			if (rti_info[RTAX_IFA] == NULL)
 				break;
@@ -879,11 +879,11 @@
 				if (rtm->rtm_type != RTM_NEWADDR)
 					break;
 #endif
 				memcpy(&sdl, rti_info[RTAX_IFA],
 				    rti_info[RTAX_IFA]->sa_len);
-				dhcpcd_handlehwaddr(ctx, ifname,
+				dhcpcd_handlehwaddr(ctx, ifp->name,
 				    (const unsigned char*)CLLADDR(&sdl),
 				    sdl.sdl_alen);
 				break;
 #ifdef INET
 			case AF_INET:
@@ -890,27 +890,28 @@
 			case 255: /* FIXME: Why 255? */
 				COPYOUT(rt.dest, rti_info[RTAX_IFA]);
 				COPYOUT(rt.net, rti_info[RTAX_NETMASK]);
 				COPYOUT(rt.gate, rti_info[RTAX_BRD]);
 				ipv4_handleifa(ctx, rtm->rtm_type,
-				    NULL, ifname,
+				    NULL, ifp->name,
 				    &rt.dest, &rt.net, &rt.gate);
 				break;
 #endif
 #ifdef INET6
 			case AF_INET6:
 				sin6 = (struct sockaddr_in6*)(void *)
 				    rti_info[RTAX_IFA];
 				ia6 = sin6->sin6_addr;
 				if (rtm->rtm_type == RTM_NEWADDR) {
-					ifa_flags = if_addrflags6(ifname, &ia6);
+					ifa_flags = if_addrflags6(ifp->name,
+					    &ia6);
 					if (ifa_flags == -1)
 						break;
 				} else
 					ifa_flags = 0;
 				ipv6_handleifa(ctx, rtm->rtm_type, NULL,
-				    ifname, &ia6, ifa_flags);
+				    ifp->name, &ia6, ifa_flags);
 				break;
 #endif
 			}
 			break;
 		}
@@ -1046,30 +1047,30 @@
 	close(s);
 	return 0;
 }
 
 int
-if_checkipv6(struct dhcpcd_ctx *ctx, const char *ifname, int own)
+if_checkipv6(struct dhcpcd_ctx *ctx, const struct interface *ifp, int own)
 {
 	int ra;
 
-	if (ifname) {
+	if (ifp) {
 #ifdef ND6_IFF_OVERRIDE_RTADV
 		int override;
 #endif
 
 #ifdef ND6_IFF_IFDISABLED
-		if (del_if_nd6_flag(ifname, ND6_IFF_IFDISABLED) == -1) {
+		if (del_if_nd6_flag(ifp->name, ND6_IFF_IFDISABLED) == -1) {
 			syslog(LOG_ERR,
 			    "%s: del_if_nd6_flag: ND6_IFF_IFDISABLED: %m",
 			    ifname);
 			return -1;
 		}
 #endif
 
 #ifdef ND6_IFF_PERFORMNUD
-		if (set_if_nd6_flag(ifname, ND6_IFF_PERFORMNUD) == -1) {
+		if (set_if_nd6_flag(ifp->name, ND6_IFF_PERFORMNUD) == -1) {
 			syslog(LOG_ERR,
 			    "%s: set_if_nd6_flag: ND6_IFF_PERFORMNUD: %m",
 			    ifname);
 			return -1;
 		}
@@ -1077,72 +1078,72 @@
 
 #ifdef ND6_IFF_AUTO_LINKLOCAL
 		if (own) {
 			int all;
 
-			all = get_if_nd6_flag(ifname, ND6_IFF_AUTO_LINKLOCAL);
+			all = get_if_nd6_flag(ifp->name,ND6_IFF_AUTO_LINKLOCAL);
 			if (all == -1)
 				syslog(LOG_ERR,
 				    "%s: get_if_nd6_flag: "
 				    "ND6_IFF_AUTO_LINKLOCAL: %m",
-				    ifname);
+				    ifp->name);
 			else if (all != 0) {
 				syslog(LOG_DEBUG,
 				    "%s: disabling Kernel IPv6 "
 				    "auto link-local support",
-				    ifname);
-				if (del_if_nd6_flag(ifname,
+				    ifp->name);
+				if (del_if_nd6_flag(ifp->name,
 				    ND6_IFF_AUTO_LINKLOCAL) == -1)
 				{
 					syslog(LOG_ERR,
 					    "%s: del_if_nd6_flag: "
 					    "ND6_IFF_AUTO_LINKLOCAL: %m",
-					    ifname);
+					    ifp->name);
 					return -1;
 				}
 			}
 		}
 #endif
 
 #ifdef ND6_IFF_OVERRIDE_RTADV
-		override = get_if_nd6_flag(ifname, ND6_IFF_OVERRIDE_RTADV);
+		override = get_if_nd6_flag(ifp->name, ND6_IFF_OVERRIDE_RTADV);
 		if (override == -1)
 			syslog(LOG_ERR,
 			    "%s: get_if_nd6_flag: ND6_IFF_OVERRIDE_RTADV: %m",
-			    ifname);
+			    ifp->name);
 		else if (override == 0 && !own)
 			return 0;
 #endif
 
 #ifdef ND6_IFF_ACCEPT_RTADV
-		ra = get_if_nd6_flag(ifname, ND6_IFF_ACCEPT_RTADV);
+		ra = get_if_nd6_flag(ifp->name, ND6_IFF_ACCEPT_RTADV);
 		if (ra == -1)
 			syslog(LOG_ERR,
 			    "%s: get_if_nd6_flag: ND6_IFF_ACCEPT_RTADV: %m",
-			    ifname);
+			    ifp->name);
 		else if (ra != 0 && own) {
 			syslog(LOG_DEBUG,
 			    "%s: disabling Kernel IPv6 RA support",
-			    ifname);
-			if (del_if_nd6_flag(ifname, ND6_IFF_ACCEPT_RTADV)
+			    ifp->name);
+			if (del_if_nd6_flag(ifp->name, ND6_IFF_ACCEPT_RTADV)
 			    == -1)
 			{
 				syslog(LOG_ERR,
 				    "%s: del_if_nd6_flag: "
 				    "ND6_IFF_ACCEPT_RTADV: %m",
-				    ifname);
+				    ifp->name);
 				return ra;
 			}
 #ifdef ND6_IFF_OVERRIDE_RTADV
 			if (override == 0 &&
-			    set_if_nd6_flag(ifname, ND6_IFF_OVERRIDE_RTADV)
+			    set_if_nd6_flag(ifp->name, ND6_IFF_OVERRIDE_RTADV)
 			    == -1)
 			{
 				syslog(LOG_ERR,
 				    "%s: set_if_nd6_flag: "
 				    "ND6_IFF_OVERRIDE_RTADV: %m",
-				    ifname);
+				    ifp->name);
 				return ra;
 			}
 #endif
 			return 0;
 		}

Index: if-linux.c
==================================================================
--- if-linux.c
+++ if-linux.c
@@ -403,11 +403,11 @@
 static int
 link_route(struct dhcpcd_ctx *ctx, __unused struct interface *ifp,
     struct nlmsghdr *nlm)
 {
 	size_t len;
-	unsigned int idx, metric;
+	unsigned int metric;
 	struct rtattr *rta;
 	struct rtmsg *rtm;
 	struct rt rt;
 	char ifn[IF_NAMESIZE + 1];
 
@@ -447,13 +447,12 @@
 		case RTA_GATEWAY:
 			memcpy(&rt.gate.s_addr, RTA_DATA(rta),
 			    sizeof(rt.gate.s_addr));
 			break;
 		case RTA_OIF:
-			idx = *(unsigned int *)RTA_DATA(rta);
-			if (if_indextoname(idx, ifn))
-				rt.iface = if_find(ctx, ifn);
+			rt.iface = if_findindex(ctx,
+			    *(unsigned int *)RTA_DATA(rta));
 			break;
 		case RTA_PRIORITY:
 			metric = *(unsigned int *)RTA_DATA(rta);
 			break;
 		}
@@ -493,15 +492,15 @@
 	if (len < sizeof(*ifa)) {
 		errno = EBADMSG;
 		return -1;
 	}
 	ifa = NLMSG_DATA(nlm);
-	if (if_indextoname(ifa->ifa_index, ifn) == NULL)
-		return -1;
-	iface = if_find(ctx, ifn);
-	if (iface == NULL)
+	if (if_findindex(ctx, ifa->ifa_index) == NULL) {
+		/* We don't know about the interface the address is for
+		 * so it's not really an error */
 		return 1;
+	}
 	rta = (struct rtattr *) IFA_RTA(ifa);
 	len = NLMSG_PAYLOAD(nlm, sizeof(*ifa));
 	switch (ifa->ifa_family) {
 #ifdef INET
 	case AF_INET:
@@ -1478,21 +1477,21 @@
 
 	nest->rta_len = (unsigned short)((char *)NLMSG_TAIL(n) - (char *)nest);
 }
 
 static int
-if_disable_autolinklocal(struct dhcpcd_ctx *ctx, const char *ifname)
+if_disable_autolinklocal(struct dhcpcd_ctx *ctx, int ifindex)
 {
 	struct nlml nlm;
 	struct rtattr *afs, *afs6;
 
 	memset(&nlm, 0, sizeof(nlm));
 	nlm.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
 	nlm.hdr.nlmsg_type = RTM_NEWLINK;
 	nlm.hdr.nlmsg_flags = NLM_F_REQUEST;
 	nlm.i.ifi_family = AF_INET6;
-	nlm.i.ifi_index = (int)if_nametoindex(ifname);
+	nlm.i.ifi_index = ifindex;
 	afs = add_attr_nest(&nlm.hdr, sizeof(nlm), IFLA_AF_SPEC);
 	afs6 = add_attr_nest(&nlm.hdr, sizeof(nlm), AF_INET6);
 	add_attr_8(&nlm.hdr, sizeof(nlm), IFLA_INET6_ADDR_GEN_MODE,
 	    IN6_ADDR_GEN_MODE_NONE);
 	add_attr_nest_end(&nlm.hdr, afs6);
@@ -1502,22 +1501,25 @@
 }
 
 static const char *prefix = "/proc/sys/net/ipv6/conf";
 
 int
-if_checkipv6(struct dhcpcd_ctx *ctx, const char *ifname, int own)
+if_checkipv6(struct dhcpcd_ctx *ctx, const struct interface *ifp, int own)
 {
+	const char *ifname;
 	int ra;
 	char path[256];
 
-	if (ifname == NULL)
+	if (ifp == NULL)
 		ifname = "all";
 	else if (own) {
-		if (if_disable_autolinklocal(ctx, ifname) == -1)
+		if (if_disable_autolinklocal(ctx, ifp->index) == -1)
 			syslog(LOG_DEBUG, "%s: if_disable_autolinklocal: %m",
 			    ifname);
 	}
+	if (ifp)
+		ifname = ifp->name;
 
 	snprintf(path, sizeof(path), "%s/%s/autoconf", prefix, ifname);
 	ra = check_proc_int(path);
 	if (ra != 1) {
 		if (!own) {

Index: if.c
==================================================================
--- if.c
+++ if.c
@@ -477,24 +477,39 @@
 
 	return ifs;
 }
 
 struct interface *
-if_find(struct dhcpcd_ctx *ctx, const char *ifname)
+if_findindexname(struct dhcpcd_ctx *ctx, unsigned int idx, const char *name)
 {
 	struct interface *ifp;
 
 	if (ctx != NULL && ctx->ifaces != NULL) {
 		TAILQ_FOREACH(ifp, ctx->ifaces, next) {
 			if ((ifp->options == NULL ||
 			    !(ifp->options->options & DHCPCD_PFXDLGONLY)) &&
-			    strcmp(ifp->name, ifname) == 0)
+			    ((name && strcmp(ifp->name, name) == 0) ||
+			    (!name && ifp->index == idx)))
 				return ifp;
 		}
 	}
 	return NULL;
 }
+
+struct interface *
+if_find(struct dhcpcd_ctx *ctx, const char *name)
+{
+
+	return if_findindexname(ctx, 0, name);
+}
+
+struct interface *
+if_findindex(struct dhcpcd_ctx *ctx, unsigned int idx)
+{
+
+	return if_findindexname(ctx, idx, NULL);
+}
 
 int
 if_domtu(const char *ifname, short int mtu)
 {
 	int s, r;

Index: if.h
==================================================================
--- if.h
+++ if.h
@@ -92,10 +92,11 @@
 
 int if_setflag(struct interface *ifp, short flag);
 #define if_up(ifp) if_setflag((ifp), (IFF_UP | IFF_RUNNING))
 struct if_head *if_discover(struct dhcpcd_ctx *, int, char * const *);
 struct interface *if_find(struct dhcpcd_ctx *, const char *);
+struct interface *if_findindex(struct dhcpcd_ctx *, unsigned int);
 void if_free(struct interface *);
 int if_domtu(const char *, short int);
 #define if_getmtu(iface) if_domtu(iface, 0)
 #define if_setmtu(iface, mtu) if_domtu(iface, mtu)
 int if_carrier(struct interface *);
@@ -129,11 +130,11 @@
 #define if_chgroute(rt) if_route(rt, 0)
 #define if_delroute(rt) if_route(rt, -1)
 #endif
 
 #ifdef INET6
-int if_checkipv6(struct dhcpcd_ctx *ctx, const char *, int);
+int if_checkipv6(struct dhcpcd_ctx *ctx, const struct interface *, int);
 int if_nd6reachable(const char *ifname, struct in6_addr *addr);
 
 int if_address6(const struct ipv6_addr *, int);
 #define if_addaddress6(a) if_address6(a, 1)
 #define if_deladdress6(a) if_address6(a, -1)

Index: if-linux.c
==================================================================
--- if-linux.c
+++ if-linux.c
@@ -84,13 +84,12 @@
 #include "ipv6nd.h"
 
 #ifdef HAVE_NL80211_H
 #include <linux/genetlink.h>
 #include <linux/nl80211.h>
-#else
+#endif
 int if_getssid_wext(const char *ifname, uint8_t *ssid);
-#endif
 
 #define bpf_insn		sock_filter
 #define BPF_SKIPTYPE
 #define BPF_ETHCOOK		-ETH_HLEN
 #define BPF_WHOLEPACKET	0x0fffffff /* work around buggy LPF filters */
@@ -468,18 +467,15 @@
 	}
 	return 1;
 }
 
 static int
-link_addr(struct dhcpcd_ctx *ctx, __unused struct interface *ifp,
-    struct nlmsghdr *nlm)
+link_addr(struct dhcpcd_ctx *ctx, struct interface *ifp, struct nlmsghdr *nlm)
 {
 	size_t len;
 	struct rtattr *rta;
 	struct ifaddrmsg *ifa;
-	char ifn[IF_NAMESIZE + 1];
-	struct interface *iface;
 #ifdef INET
 	struct in_addr addr, net, dest;
 #endif
 #ifdef INET6
 	struct in6_addr addr6;
@@ -492,11 +488,11 @@
 	if (len < sizeof(*ifa)) {
 		errno = EBADMSG;
 		return -1;
 	}
 	ifa = NLMSG_DATA(nlm);
-	if (if_findindex(ctx, ifa->ifa_index) == NULL) {
+	if ((ifp = if_findindex(ctx, ifa->ifa_index)) == NULL) {
 		/* We don't know about the interface the address is for
 		 * so it's not really an error */
 		return 1;
 	}
 	rta = (struct rtattr *) IFA_RTA(ifa);
@@ -508,11 +504,11 @@
 		dest.s_addr = INADDR_ANY;
 		inet_cidrtoaddr(ifa->ifa_prefixlen, &net);
 		while (RTA_OK(rta, len)) {
 			switch (rta->rta_type) {
 			case IFA_ADDRESS:
-				if (iface->flags & IFF_POINTOPOINT) {
+				if (ifp->flags & IFF_POINTOPOINT) {
 					memcpy(&dest.s_addr, RTA_DATA(rta),
 					       sizeof(addr.s_addr));
 				}
 				break;
 			case IFA_LOCAL:
@@ -520,11 +516,11 @@
 				       sizeof(addr.s_addr));
 				break;
 			}
 			rta = RTA_NEXT(rta, len);
 		}
-		ipv4_handleifa(ctx, nlm->nlmsg_type, NULL, ifn,
+		ipv4_handleifa(ctx, nlm->nlmsg_type, NULL, ifp->name,
 		    &addr, &net, &dest);
 		break;
 #endif
 #ifdef INET6
 	case AF_INET6:
@@ -536,11 +532,11 @@
 				       sizeof(addr6.s6_addr));
 				break;
 			}
 			rta = RTA_NEXT(rta, len);
 		}
-		ipv6_handleifa(ctx, nlm->nlmsg_type, NULL, ifn,
+		ipv6_handleifa(ctx, nlm->nlmsg_type, NULL, ifp->name,
 		    &addr6, ifa->ifa_flags);
 		break;
 #endif
 	}
 	return 1;
@@ -1512,11 +1508,11 @@
 	if (ifp == NULL)
 		ifname = "all";
 	else if (own) {
 		if (if_disable_autolinklocal(ctx, ifp->index) == -1)
 			syslog(LOG_DEBUG, "%s: if_disable_autolinklocal: %m",
-			    ifname);
+			    ifp->name);
 	}
 	if (ifp)
 		ifname = ifp->name;
 
 	snprintf(path, sizeof(path), "%s/%s/autoconf", prefix, ifname);

